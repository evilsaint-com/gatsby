{"componentChunkName":"component---src-templates-blog-post-js","path":"/tutorials/cmd-tutorial/","result":{"pageContext":{"post":{"fields":{"slug":"/cmd-tutorial"},"excerpt":null,"frontmatter":{"date":"17th September 2021 ","title":"CMD Tutorial","description":"","tags":"cmd, windows","posttype":"tutorial"},"body":"---\ntitle: CMD \nweight: 10\n---\n# CMD\n\n## For Loops\n\nOverview\n\nFOR\tLoop through a set of files in one folder\n```\nFOR /R\tLoop through files (recurse subfolders)\nFOR /D\tLoop through several folders\nFOR /L\tLoop through a range of numbers\nFOR /F\tLoop through items in a text file\nFOR /F\tLoop through the output of a command\n```\n\nA loop with no modifier options will run a specified command for each file in a set of files (won't act on directories).\n```\nFOR %variable IN (set) DO command [command-parameters]\n```\n\n> To use the FOR command in a batch program, specify `%%variable` instead of `%variable`. Variable names are case sensitive, so `%i` is different from `%I`\n\n### For Loop Modifiers\n\nUsing the /D modifier modifies are loop so that it only iterates and acts over files\n```\nFOR /D %variable IN (set) DO command [command-parameters]\n```\n\nUsing the /R modifier we are able to walk recursively listing files. We can either add a drive and path after the /R option and we will start recursively from that point. If we miss out the drive and path then we start recursive from the working directory.\n```\nFOR /R [[drive:]path] %variable IN (set) DO command [command-parameters]\n```\n\nUsing the /L modifier we can loop over sequences of numbers from start to end, and even indicate what amount to step up by\n```\nFOR /L %variable IN (start,step,end) DO command [command-parameters]\n```\n> The set is a sequence of numbers from start to end, by step amount. So (1,1,5) would generate the sequence 1 2 3 4 5 and (5,-1,1) would generate the sequence (5 4 3 2 1)\n\n#### The /F modifier\n\nThe /F modifier can be used to construct some very powerful loops.\n\nEach file is opened, read and processed before going on to the next file in file-set. Processing consists of reading in the file, breaking it up into individual lines of text and then parsing each line into zero or more tokens.\n```\nFOR /F [\"options\"] %variable IN (file-set) DO command [command-parameters]\nFOR /F [\"options\"] %variable IN ('string') DO command [command-parameters]\nFOR /F [\"options\"] %variable IN (`command`) DO command [command-parameters]\n```\n\n| Option | Description                                                         |\n| ------ | ------------------------------------------------------------------- |\n| eol=c  | specifies an end of line comment character (just one)               |\n| skip=n | specifies the number of lines to skip at the beginning of the file. |\n| delims=xxx  | \tspecifies a delimiter set.  This replaces the default delimiter set of space and tab. |\n| tokens=x,y,m-n |\tspecifies which tokens from each line are to be passed to the for body for each iteration. This will cause additional variable names to be allocated. The m-n form is a range, specifying the mth through the nth tokens. If the last character in the tokens= string is an asterisk, then an additional variable is allocated and receives the remaining text on the line after the last token parsed. |\n| usebackq   |    \tspecifies that the new semantics are in force, where a back quoted string is executed as a command and a single quoted string is a literal string command and allows the use of double quotes to quote file names in filenameset. |\n\nExamples of the different loops\n\nLoop through all files\n```\nC:\\ for %i in (C:\\Windows\\System32\\*) do @echo name: %i attrib: %~ai\n```\nLoop through all directories (only difference is addition of /D)\n```\nC:\\ for /D %i in (C:\\Windows\\System32\\*) do @echo name: %i attrib: %~ai\n```\nLoop through all files recursively\n```\nfor /R C:\\Windows %i in (*) do @echo name: %i attrib: %~ai\n```\nLoop through all folders recursively\n```\nfor /R C:\\Windows /D %i in (*) do @echo name: %i attrib: %~ai\n```\nA loop around a sequence of numbers between 2-254 piped to ping to make a ping sweeper\n```\nfor /L %i in (2,1,254) do ping -n 2 127.0.0.%i\n```\n\nBatch File Loops\n\nHere is how we would write FOR loops inside a batch file with the %%.\n\nLoop through text files and echo file name\n```\nfor %%F IN (*.txt) DO @echo %%F\n```\n\nLoop through text files and output the file contents\n```\nfor %%F IN (*.txt) DO @echo %%F\n```"},"prev":{"fields":{"slug":"/c-tutorial"},"excerpt":null,"frontmatter":{"date":"17th September 2021 ","title":"C Tutorial","description":"","tags":"c","posttype":"tutorial"},"body":"# C\nC is a general-purpose, procedural computer programming language, developed by\nR&D company Bell Labs back in 1972. It's a widely used programming language,\nmost notably in systems programming for operating systems, compilers,\ninterpreters, libraries of other programming languages and in implementations\nof embedded system applications. For example, Linux and Windows kernel are\nwritten in C, most of GNU components and also Python, PHP, Ruby, Perl interpreters.\n\nBefore a C program can do anything, it first needs to be compiled,\ni.e. translated from C source into a binary code which can instruct the CPU.\n\nThe C language provides no built-in facilities for performing common\noperations such as input/output, memory management, string manipulation, and the others. Instead, these facilities are defined in a standard libraries, which you compile and link with your programs.\n\nInformation about standard and other libraries should be included inside the first lines of the code. The following line includes the standard input/output\nlibrary, where 'stdio.h' is the name of the library's header file.\n\n\n```c\n#include <stdio.h>\n```\n\nNow, some brief notes about the C program: it consists of functions and variables. A function contains statements that specify the computing\noperations, and variables store values used during the computation. Communication between the functions is by arguments and values returned by the functions, and through external variables.\nThe return statement defines a value to be returned from the called function to its caller.\n\nYou can name your functions however you want, with the exception of the name\n'main'. Function called 'main' is special - your program begins executing\nat the beginning of the main. This means that every program must have a main\ndefined somewhere in code.\n\n\n```c\n#include <stdio.h>\n\nint main() {\n  printf(\"Goodbye, World!\");\n  return 0;\n}\n```\nWhen we write `int main()` we are stating that our program will return and integer. The number returned by the function indicates whether the\nprogram we wrote worked correctly. A return of 0 mean our programmed returned\nsuccessfully, a number greater than 0 means it failed. Every line in C must end\nwith a semicolon, so that the compiler knows that a new line has started.\n\n\n\n## Variables\n\n\n### Types\n\nThere are only a few basic data types in C:\n\n - ``char`` - single byte, capable of holding one character in the local character set.\n\n - ``int`` - integer, typically reflecting the natural size of integers on the host machine.\n\n - ``float`` - single-precision floating point.\n\n - ``double`` - double-precision floating point\n\nIn addition, there are a number of qualifiers that can be applied to these\nbasic types. ```short``` and ```long``` apply to integers:\n\n```c\nshort int var_one;\nlong int var_two;\n```\n\nNote: 'int' can be omitted in these declarations.\n\n\n### Defining variables\n\nAll variables must be declared before use, although certain declarations can\nbe made implicitly by content. A declaration specifies a type, and contains a\nlist of one or more variables of that type, as in\n\n```c\nint lower, upper, step;\nchar c, line[1000];\n```\n\nFor whole numbers, int type is used, which an integer in the size of a \"word\"\nthe default number size of the machine which your program is compiled on. On\nmost computers today, it is a 32-bit number, which means the number can range\nfrom -2,147,483,648 to 2,147,483,647.\n\n```c\nint a = 0,b = 1,c = 2,d = 3, e = 4;\na = b - c + d * e;\nprintf(\"%d\", a); /* will print 1-2+3*4 = 11 */\n```\n\n\nDeclaring Strings\n```c\nchar name[] = \"John Smith\";\n/* is the same as */\nchar name[11] = \"John Smith\";\n```\n\nThe reason that we need to add one, although the string John Smith is exactly 10 characters long, is for the string termination, a special character (equal to 0) which indicates the end of the string. The end of the string is marked because the program does not know the length of the string - only the compiler knows it according to the code.\n\nUsing a pointer to define a simple string. This method creates a string which can only be used for reading\n```c\nchar * name = \"John Smith\";\n```\n\nString formatting with `printf`\n```c\nchar * name = \"John Smith\";\nint age = 27;\n\n/* prints out 'John Smith is 27 years old.' */\nprintf(\"%s is %d years old.\\n\", name, age)\n```\n\nString Length - The function `strlen` returns the length of the string which has to be passed as an argument:\n```c\nchar * name = \"Nikhil\";\nprintf(\"%d\\n\",strlen(name));\n```\n\n\n## Operators\n\n### Unary operators\n\nUnary operators are placed as prefix relative to operands and operate on\nsingle a operand. E.g. incrementing a 'var' variable with '++' operator.:\n```c\n++var;\n```\n\n#### Increment and decrement operators\n\n** ++ ** - Increment operatror-\n** -- ** - Decremet operator.\n\n#### Address and indirection operators\n\n** & ** - Address Operator. Yields the address of the operand.\n** * ** - Indirection operator. Yields the object or function to which its operand points, also known as pointer.\n** + ** - Unary Plus Operator. Yields the value of the operand, which must be of arithmetic type.\n** - ** - Unary Minus Operator. Yields the negative value of the operand, which must be of arithmetic type.\n** ~ ** - One's Complement Operator. Yields the complement value of the operand, which must be of integral type.\n** ! ** - Logical Negation Operator. Yields 1 if the value of its operand compares equal to 0, and 0 otherwise.  \n** sizeof ** -Sizeof Operator. Yields the number of bytes required to store an object of the type of its operand.\n\n### Multiplicative operators\n** * ** - Multiplication Operator. Yields the multiple of two operands, both of whcih must be of arithmetic type.\n** / ** - Division Operator. Yields the divison of first by the second operand, both of which must be of arithmetic type.\n** % ** Remainder Operator. Yields the remainder of divison of first operand by the second, both of which must be of integral type.\n\n### Additive Operators\nIf the operands have arithmetic type, the usual arithmetic conversions are performed.\n\n** + ** - Yields the sum of operands.\n** - ** - Yields the value of the first operand subtracted by the value of second.\n\n### Shift Operators\n\n### Equality Operators\n\n### Relational operators\n\n### Bitwise AND Operator\n\n### Bitwise Exclusive OR Operator\n\n### Logical AND Operator\n\n### Logical OR Operator\n\n### Conditional Operator\n\n### Assignment Operators\n\n### Comma Operator\n\n\n## Arrays\nAn 'array' type variable is a contiguously allocated nonempty set of objects,\nalos called elements, with a particular member object type. Each object can\nbe accessed via subscript, also called index, number. In C, index number starts from 0 since it\nreferences a memory location offset by ```n``` objects away from the first element.\n\nArrays are defined in a very straightforward syntax:\n\n```c\nint numbers[10];\n```\n\nThe example above defines an array containing 11 objects, indexed from 0 to\n10, of type 'int'.\n\n\nWe can assign and retrive as follows:\n\n```c\n//int numbers[10];\n/* populate the array */\nnumbers[0] = 10;\nnumbers[1] = 20;\nnumbers[2] = 30;\nnumbers[3] = 40;\nnumbers[4] = 50;\nnumbers[5] = 60;\nnumbers[6] = 70;\n\n/* print the 7th number from the array, which has an index of 6 */\nprintf(\"The 7th number in the array is %d\", numbers[6]);\n```\n\nHere is the general form of a multidimensional array declaration:\n```c\ntype arrayName [x][y];\n```\n\nInitialise a two dimensional array\n```c\nint a[3][4] = {\n   {0, 1, 2, 3} ,   /*  initializers for row indexed by 0 */\n   {4, 5, 6, 7} ,   /*  initializers for row indexed by 1 */\n   {8, 9, 10, 11}   /*  initializers for row indexed by 2 */\n};\n```\n\nThe inside braces, which indicates the wanted row, are optional. The following initialization is the same to the previous example.\n```c\nint a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};\n```\n\nLet's access a two-dimensional element\n```c\nint val = a[2][3];\n```\n\nExample program using multidimensional arrays\n```c\n     #include <stdio.h>\n\n     int main() {\n          int grades[2][5];\n          float average;\n          int i;\n          int j;\n\n          grades[0][0] = 80;\n          grades[0][1] = 70;\n          grades[0][2] = 65;\n          grades[0][3] = 89;\n          grades[0][4] = 90;\n\n          grades[1][0] = 85;\n          grades[1][1] = 80;\n          grades[1][2] = 80;\n          grades[1][3] = 82;\n          grades[1][4] = 87;\n\n          for (i = 0; i < 2; i++) {\n               average = 0;\n\n               for (j = 0; j < 5; j++) {\n                    average += grades[i][j];\n               }\n\n               average /= 5.0;\n               printf(\"The average marks obtained in subject %d is: %.2f\\n\", i, average);\n          }\n\n          return 0;\n     }\n```\n\n## Selection (Conditional) statements\nA selection statement is a flow of control mechanism which selects among a set of substatements depending on the value of a controlling expression. The first substatement whose conditional expression, which must be arithmetic or pointer type, is evaluated to be unequal to 0 is executed.\n\nSelection statement can be in three forms:\n```\n//pseudocode\nif (expression) statement\nif (expression) statement else statement\nswitch (expression) statement\n```\n\nIn the follwoing example:\n```c\nif ( var < 4 ) {\n   printf( \"var is less than 4.\" );\n} else {\n   printf( \"var is larger than 4.\" );\n}\n```\n\n\n## Loops\n\n### For Loops\n\n\nUsing a for loop to iterate over a block 10 times.\n```c\nint i;\nfor (i = 0; i < 10; i++) {\n    printf(\"%d\\n\", i);\n}\n```\n\nFor loops can iterate over arrays\n```c\nint array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\nint sum = 0;\nint i;\n\nfor (i = 0; i < 10; i++) {\n    sum += array[i];\n}\n\n/* sum now contains a[0] + a[1] + ... + a[9] */\nprintf(\"Sum of the array is %d\\n\", sum);\n```\n\n### While Loops\n\nWhile loops are like for loops but have less functionality. A while loop continues executing the while block as long as the condition in the while holds true.\n```c\nint n = 0;\nwhile (n < 10) {\n    n++;\n}\n```\n\nWhile loops can also execute infinitely if a condition is given which always evaluates as true (non-zero):\n```c\nwhile (1) {\n   /* do something */\n}\n```\n\nNOTE: the `break` and `continue` directives.\n\nThe break directive halts a loop after ten loops, even though the while loop never finishes:\n```c\nint n = 0;\nwhile (1) {\n    n++;\n    if (n == 10) {\n        break;\n    }\n}\n```\n\nIn the following code, the continue directive causes the printf command to be skipped, so that only even numbers are printed out:\n```c\nint n = 0;\nwhile (n < 10) {\n    n++;\n\n    /* check that n is odd */\n    if (n % 2 == 1) {\n        /* go back to the start of the while block */\n        continue;\n    }\n\n    /* we reach this code only if n is even */\n    printf(\"The number %d is even.\\n\", n);\n}\n```\n\n## Functions\n\n* Functions receive either a fixed or variable amount of arguments.\n* Functions can only return one value, or return no value.\n\nExample function definition\n```c\nint foo(int bar) {\n    /* do something */\n    return bar * 2;\n}\n\nint main() {\n    foo(1);\n}\n```\n\nIn C, functions must be first defined before they are used in the code. They can be either declared first and then implemented later on using a header file or in the beginning of the C file, or they can be implemented in the order they are used (less preferable).\n\nThe correct way to use functions is as follows:\n```c\n/* function declaration */\nint foo(int bar);\n\nint main() {\n    /* calling foo from main */\n    printf(\"The value of foo is %d\", foo(1));\n}\n\nint foo(int bar) {\n    return bar + 1;\n}\n```\n\nWe can also create functions that do not return a value by using the keyword void:\n```c\nvoid moo() {\n    /* do something and don't return a value */\n}\n\nint main() {\n    moo();\n}\n```\n\n## Static Variables, Refercences and Pointers\n\n**What is a static variable?**\n\nBy default, variables are local to the scope in which they are defined. Variables can be declared as static to increase their scope up to file containing them. As a result, these variables can be accessed anywhere inside a file.\n\n**References And Pointers**\n\nA pointer is essentially a simple integer variable which holds a memory address that points to a value, instead of holding the actual value itself.\n\nDereferencing is the act of referring to where the pointer points at.\n```c\n#include <stdio.h>\n\nint main() {\n    /* define a local variable a */\n    int a = 1;\n\n    /* define a pointer variable, and point it to a using the & operator */\n    int * pointer_to_a = &a;\n\n    printf(\"The value a is %d\\n\", a);                          /* 1 */\n    printf(\"The value of a is also %d\\n\", *pointer_to_a);      /* 1 */\n    printf(\"The address of a is %d\\n\", pointer_to_a);          /*  713939084*/\n    printf(\"The address of a is %d\\n\", &a);                    /*  713939084*/\n\n    return 0;\n}\n```\n\n## Structures\n\nC structures are special, large variables which contain several named variables inside. Structures are the basic foundation for objects and classes in C. Structures are used for:\n* Serialization of data\n* Passing multiple arguments in and out of functions through a single argument\n* Data structures such as linked lists, binary trees, and more\n\nDefining a structure\n```c\nstruct point {\n    int x;\n    int y;\n}\n```\n\nDeclaring a struct upfront and then building it on the fly\n```c\nstruct point p;\np.x = 10;\np.y = 5;\ndraw(p);\n```\n\nExample of struct and typedef\n```c\ntypedef struct {\n    char * brand;\n    int model;\n} vehicle;\n\nvehicle mycar;\nmycar.brand = \"Ford\";\nmycar.model = 2007;\n```\n\n## Function arguments by reference\n\nFunction arguments are passed by value, which means they are copied in and out of functions. But what if we copied pointers to values instead of the values themselves? This will enable us to give functions control over variables and structures of the parent functions, and not just a copy of them.\n\nBecause we pass in the memory location and reference it inside via a pointer, this example allows us to increment `n` outside of the function\n```c\nvoid addone(int * n) {\n    (*n)++;\n}\n\nint n;\nprintf(\"Before: %d\\n\", n);\naddone(&n);\nprintf(\"After: %d\\n\", n);\n```\n\n## Compiling\n\nCompile C code.\n```\ngcc -o output.c input.c\n```\n\nCross compile C code, compile 32 bit binary on 64 bit Linux.\n```\ngcc -m32 -o output.c input.c\n```\n\nCompile a binary for Windows on Linux\n```\ni686-w64-mingw32-gcc -o program.exe mycode.c\n```\n\n## Useful Snippets\n\nAn add windows user program\n\ncat useradd.c\n```c\n/* system, NULL, EXIT_FAILURE */\n\n#include <stdlib.h>\n\nint main ()\n{\nint i;\ni=system (\"net localgroup administrators myuser /add\");\nreturn 0;\n}\n```\n\nNow we compile this while on Linux\n```\ni686-w64-mingw32-gcc -o adduser.exe useradd.c\n```"},"next":{"fields":{"slug":"/perl-tutorial"},"excerpt":null,"frontmatter":{"date":"17th September 2021 ","title":"Perl Tutorial","description":"","tags":"perl","posttype":"tutorial"},"body":"\n# Perl\n\nWhile many canned security tools are available on this site for handling common tasks, scripting languages allow you to write your own (or modify existing ones) when you need something more custom. Quick, portable scripts can test, exploit, or even fix systems. Archives like <a href=\"http://www.cpan.org\">CPAN are filled with modules such as <a href=\"http://www.ic.al.lg.ua/~ksv/\">Net::RawIP and protocol implementations to make your tasks even easier. Many security tools use scripting languages heavily for extensibility. For example <a class=\"local\" href=\"/tool/scapy/\">Scapy interaction is through a Python interpreter, <a class=\"local\" href=\"/tool/metasploit/\">Metasploit modules are written in Ruby, and <a href=\"http://nmap.org\">Nmap's scripting engine uses Lua.\n\nhttp://www.perl.org\nhttp://www.python.org\nhttp://www.ruby-lang.org\n\n* All official versions are free of charge\n* Works natively on Linux.\n* Works natively on Apple Mac OS X.\n* Works natively on Microsoft Windows.\n* Features a command-line interface.\n* Source code available for inspection.\n* General-purpose tools"}}},"staticQueryHashes":["310218920"],"slicesMap":{}}