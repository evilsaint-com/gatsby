{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/auditing-cisco-network-devices/","result":{"pageContext":{"post":{"fields":{"slug":"/auditing-cisco-network-devices"},"excerpt":"Look out for device administrative (console and aux) lines that are configured without a password. An attacker with physical access to the…","frontmatter":{"date":"15th April 2021 ","title":"Auditing Cisco Network Devices","description":"","tags":null,"posttype":"article"},"body":"\n# Administrative Line Login With No Password\n\nLook out for device administrative (console and aux) lines that are configured without a password. An attacker with physical access to the ports, or with remote modem access, would be able to access the host. Any access could lead to system compromise, packet sniffing, or denial of service.\n\nEnsure that authentication is configured on all ports. Shut down any ports that are not in use.\nThe authentication mechanism and authentication password can be configured on administrative lines using the following line mode commands:\n```\nlogin [tacacs | local]\npassword password\n```"},"prev":{"fields":{"slug":"/git-with-ssh-keys"},"excerpt":null,"frontmatter":{"date":"15th April 2021 ","title":"Git with SSH Keys","description":"When working with Git via command line, the easiest way to authenticate is with x.509 keys. This article will show you how to set them up.","tags":"git, github, github-desktop, source-tree, ssh-keys, x509","posttype":"article"},"body":"\nWhen working with Git via command line, the easiest way to authenticate is with x.509 keys. This article will show you how to set them up. \n\n## Introduction \n\nWith GUI-based Git clients, such as GitHub Desktop and SourceTree, authentication is managed by the applications themselves with little to no user input required.\n\nHowever, sometimes you may want to use the power of the command line, in which case it is useful to have SSH keys set up.\n\n## SSH Key Location\n\nSSH keys are stored at the following locations depending on the operating system and/or the user.\n\nOn Linux - assuming you are not using the root user ;-)\n```\n/home/<user>/.ssh \n```\nor \n\nRoot user\n```\n/root/.ssh\n```\n\nBoth of these can be shortened using the tilde `~`, which is a shortcut for home. You can use tilde with many commands to save you from typing the full path. For example, you could have `cd ~` that would take you to your home directory. The two commands mentioned above could be shortened to the following.\n```\n~/.ssh\n```\n\nOn Windows, the typical location for SSH keys is\n```\nC:\\User\\<username>\\.ssh\n```\n\n## Listing Keys\n\nNow that we have learned where the SSH keys are stored on our system let us look at how we can list the contents of this folder.\n\nLinux\n```\nls -l ~/.ssh\n```\n\n<figure class=\"figure text-center col-xs-12 col-sm-12 col-lg-12\">\n  <img src=\"/media/markdown/2021/03/28/12eb72b9-f324-4f50-a9f9-0aa5bac57858.png\" class=\"img-fluid\" alt=\"Git with SSH Keys\">\n<figcaption class=\"figure-caption text-center fw-normal text-dark\">Git with SSH Keys.</figcaption>\n</figure>\n\nWindows CMD\n```\ndir c:\\users\\<username>\\.ssh\n```\n\n<img src=\"/media/markdown/2021/03/28/9b4a3962-ecf6-4b7b-ae7f-36bbe5ddec07.png\" class=\"img-fluid\" alt=\"untitled\">\n\nWindows PowerShell\n```\nGet-ChildItem C:\\Users\\<username>\\.ssh\n```\n\n<img src=\"/media/markdown/2021/03/28/181e4ae6-5cb4-4d22-9119-fdbddee95beb.png\" class=\"img-fluid\" alt=\"untitled\">\n\n> **Note** It is quite common to have multiple keys in this folder as keys can be used for many things other than Git. \n\n## Existing SSH keys\n\nIf you are learning about SSH keys and using them to authenticate to Git Repositories for the first time, the above folders likely are empty on your system. In this case, please take a look at the screenshots above. You will notice that the keys are named in pairs; one key ends in the `.pub` extension, and the other has no extension at all. \n\nThe file ending in `.pub` contains the public key, while the other file contains the private key. The private key should never be shared anywhere. If you lose your private key, you will need to regenerate a new private/public key pair, as authentication cannot be successfully completed without both parts. \n\nIt should be noted that you can regenerate a public key with just the private key; however, you cannot generate a new private key from a public key. \n\n## Generating Your First SSH Key-pair\n\nTo generate a brand new key pair, you can use the SSH keygen command `ssh-keygen`, which is available on most versions of *nix, Mac OS, and Windows with either the Windows Subsystem for Linux (WSL) or the Git Windows Desktop package. \n\n\nHere's the command you want to use\n```\nssh-keygen -t rsa -b 4096 -C \"<comment>\"\n```\n| Option     | Description                              |\n|------------|------------------------------------------|\n| -t type    | The type option states the type of encryption to use. The possible values are \"dsa\", \"ecdsa\" or \"rsa\". Please note this is RSA version 2; for RSA version 1, you need to change this to \"rsa1\". |\n| -b bits    | This option specifies the number of bits in the key to create.  For RSA keys, I like to use 4096 bits, the default is 2048, and the minimum is 768 bits. When working with DSA keys, it is important to note that the DSA keys must be exactly 1024 bits. For ECDSA keys, the -b flag determines the key length by selecting from one of three elliptic curve sizes: 256, 384 or 521 bits.  Attempting to use bit lengths other than these three values for ECDSA keys will fail. |\n| -C comment | Allows for a comment to be added to the public key |\n\n\n> **Note** The comment field is typically filled in with the key owner's email address, but it can actually be anything you want it to be. You could enter a random string or a note about the client device or service being used. It is, however, recommended that you do not enter vague or unclear content in this space and instead use something that will allow you to identify the owner/purpose of the keys years down the road. \n\nAfter we have decided on a specific type, bits, and comment text, we are ready to generate our keys. Upon typing the command and hitting enter, the first thing you will be asked is where you would like to store the newly generated keys. Typically, you are advised to store the keys in one of the default locations, which we looked at earlier with the suggested id_<type> key name. Examples include id_rsa, id_dsa, and id_ecdsa. Personally, I prefer to name my keys with something a little more memorable. If you look at the screenshots above, you will see that I like to use distinctive key names, such as `github_rsa`.\n\nNext, you will be asked if you would like to add a passphrase. The purpose of the passphrase is to encrypt your private key. Encrypting the private key makes the file useless in case the key is compromised. It is not unusual for computers to be lost or stolen or for old hardware to be decommissioned without the hard disc being wiped.  \n\nThe passphrase is needed to use the encrypted key. Some less security-conscious users often state not seeing the point of using SSH keys when they will still have to type in their authentication credentials each time, and as a result, will often leave the passphrase blank. This is the wrong way of looking at the purpose of SSH keys. The passphrase acts as a separate factor of authentication. Keep in mind that it is much more difficult to brute-force an SSH key than it is a password; however, on its own, the key may be vulnerable to theft, and so the password is its last line of defence. \n\n## Adding SSH Keys to Git\n\nAs shown in the pictures below, setting up Git to work with SSH keys is a similar process on Github and Gitlab. \n\n**Gitlab**\n\nFirst, let us look at Gitlab. \n\n\nClick on the profile icon in the top right, and a drop-down menu will appear. Select the menu item \"Settings\". \n\n<img src=\"/media/markdown/2021/03/28/6661bfce-eff2-48e2-b6fc-b1b7e1c78d4a.png\" class=\"img-fluid\" alt=\"untitled\">\n\nAnother menu should be located on the left-hand side of the settings page. On it, click on the \"SSH Keys\" option.\n\n<img src=\"/media/markdown/2021/03/28/717dc1cb-dcee-4a0f-bbec-c77dbf41a46c.png\" class=\"img-fluid\" alt=\"untitled\">\n\nYou will be presented with an input box to paste your public key (the one that ends in `.pub`). Paste your key into the input box and give your key a title that will allow you to recall the device or user that will be authenticated. Make sure that this is something you will remember years down the road, as it can be difficult to debug over time if you are left to analyse an ambiguous clue. Finally, you can submit an expiry date which is useful if you have third party developers or contractors working in your repository. \n\n<img src=\"/media/markdown/2021/03/28/1ed759c3-ff88-4f51-812e-d3871577f2d0.png\" class=\"img-fluid\" alt=\"untitled\">\n\n**GitHub**\n\nAs we will see, Github follows a similar process to that of adding SSH keys to Gitlab, albeit with an extra step. \n\nClick on the profile icon in the top right corner, and a drop-down menu will appear. Select the menu item \"Settings\". \n\n<img src=\"/media/markdown/2021/03/28/a4f73a87-15e2-44e5-93ab-c099f8b9ad7d.png\" class=\"img-fluid\" alt=\"untitled\">\n\nA menu should be located on the left-hand side of the settings page. Click on the \"SSH and GPG Keys\" option.\n\n<img src=\"/media/markdown/2021/03/28/1afb1f1b-5850-4a96-b614-2fba14eaca42.png\" class=\"img-fluid\" alt=\"untitled\">\n\nAt this point of the Gitlab setup, we would be presented with an input field to paste our SSH key into, below which would be a list of all our existing keys. With Github, however, we are presented with a list of our existing keys and a green button that says \"New SSH Key\". Click on this button, and you will be presented with an input box similar to that provided on Gitlab. \n\n<img src=\"/media/markdown/2021/03/28/2aa08fdb-7de5-4118-b643-3df041128996.png\" class=\"img-fluid\" alt=\"untitled\">\n\nAn input box to paste your public key (the one that ends in `.pub`) will be presented to you. Paste your key into the input box and give your key a title that will allow you to recall the device or user that will be authenticated. Make sure that this is something you will remember years down the road, as it can be difficult to debug over time if you are left to analyse an ambiguous clue. Unlike Gitlab, Github does not allow you to set a key that expires. \n\n<img src=\"/media/markdown/2021/03/28/310ea5bf-0523-4254-8483-69c5b0459291.png\" class=\"img-fluid\" alt=\"untitled\">\n\n## Using multiple keys\n\nAs I mentioned at the beginning of this article, you may have multiple SSH keys on your system. In fact, I prefer to create a new SSH keypair for each service. \n\nWhy?\n\nIf a keypair becomes compromised, it is much easier to regenerate one keypair than it is to change it in multiple locations. \n\nIt is recommended that you use a different SSH key for every service you intend to use. This makes it very easy to invalidate a key on a specific service without having to change it on all the services, should you decide to renew it either because it has been compromised / publicly exposed or for any other reason."},"next":{"fields":{"slug":"/5-uses-for-power-shell-on-pentests"},"excerpt":null,"frontmatter":{"date":"15th April 2021 ","title":"5 Uses for PowerShell on Pentests","description":"Five ways of using PowerShell on your pentests.","tags":"powershell","posttype":"article"},"body":"## 1, Checking for duplicate files\n\nFinding duplicate files can be a tricky task, especially when you have 100's of files spread all over your hard drive.  An easy way is to compute the checksum of the files you would like to check and compare them. If we generate checksums for two files, we can declare that the two files aren’t duplicates if the checksums are different. If the checksums are equal, we can claim that the files are identical, considering that getting the same hash for two different files is almost impossible.\n\nCollisions can occur with Sha1 and MD5, so it is recommended you either double-check with both algorithms (as a collision on both will be unlikely) or use an algorithm such as Sha512.\n\nWe can use the following function to get the checksum of any file. \n\n```powershell\nGet-FileHash -Algorithm sha1 file.txt\n```\n\nThe `Get-FileHash` algorithm attribute supports the following:\n\n- SHA1 (160 bits)\n- SHA256 (256 bits)\n- SHA384 (384 bits)\n- SHA512 (512 bits)\n- MACTripleDES (64 bits)\n- MD5 (128 bits)\n- RIPEMD160 (160 bits)\n\n<img src=\"/static/ea89c0fc-5aea-4f88-9257-4ca0e3121921.png\" class=\"img-fluid\" alt=\"untitled\">\n\n\n## 2 Create ISO files\n\n### What are ISO files?\n\nISOs are a type of archive. The easiest way to think of an ISO file is more like a .zip or .cab archive file, only without the compression. An ISO file contains the image of a disk. That means it contains all the files and folders on that disk, much like a .zip or .cab file containing a collection of files and folders.\n\n### What are some of the benefits of ISO files.\n\n- Chances of getting viruses in your file are reduced.\n- Chances of your data being corrupt are reduced after creating an ISO file.\n- A single ISO file can hold a whole batch of files and tools.\n\nUsing the code, we can find it at the following location. We can create an ISO file for storing tools and documents inside and mounting them inside our virtual machines. \n\n[New-ISOFile function](https://gallery.technet.microsoft.com/scriptcenter/New-ISOFile-function-a8deeffd)\n\nTo make the script easier to call, we will put it in our profile. See the following link for more information about PowerShell profiles and the appropriate location.\n\n[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.1#the-profile-files](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.1#the-profile-files)\n\n```powershell\nNew-Item -ItemType Directory $Home\\Documents\\PowerShell\\\nNew-Item $Home\\Documents\\PowerShell\\Profile.ps1\nnotepad $Home\\Documents\\PowerShell\\Profile.ps1\n```\n\n<img src=\"/static/b997e7f9-e47c-4b85-8ca3-7973dd4dd150.png\" class=\"img-fluid\" alt=\"untitled\">\n\nWith the function saved in our profile, we can now create an ISO. Let us use the text files we created earlier. \n\n```powershell\ngci * | New-ISOFile -Path textfile.iso\n```\n\n<img src=\"/static/099f6a05-4dd0-48b1-93ef-f7f18d4987d3.png\" class=\"img-fluid\" alt=\"untitled\">\n\nLets now mount the disk and boot up our VM\n\n<img src=\"/static/a1907569-7cbb-4654-8c61-749523497c25.png\" class=\"img-fluid\" alt=\"untitled\">\n\nSetting the CD player path to the path of the ISO we just created. \n\n<img src=\"/static/98a87e5c-8ad8-452d-bd90-31f5e01e3f37.png\" class=\"img-fluid\" alt=\"untitled\">\n\n\nThe drive has appeared and seems to have content in it.\n\nLet's hit `Ctrl` + `E` to open up Explorer and navigate our mounted ISO.\n\n<img src=\"/static/24ba6ce8-449c-4c35-ad9f-ebcb72de8954.png\" class=\"img-fluid\" alt=\"untitled\">\n\nOut ISO contains the three files from earlier. \n\n## 3, Using PowerShell to Show Server Response Headers\n\nUsing the `Invoke-WebRequest` or the valid and shortened `iwr`, we can retrieve interesting information. \n\nThe returned object from `Invoke-WebRequest` will allow you to see items such as the returned HTTP status code, the links on a page, the forms on the page and the returned server headers. \n\n```powershell\n$request = Invoke-WebRequest https://evilsaint.co.uk\n$request.StatusCode\n$request.Headers\n$request.RawContent > temp.html\n```\n\nWhat these Headers mean I will leave for a future article, but here is a useful reference in the mean-time:\n\n[The HTTP Response Headers List](https://flaviocopes.com/http-response-headers/)\n\n<img src=\"/static/aee90e1c-ba46-4a56-920d-9b57a75268a8.png\" class=\"img-fluid\" alt=\"untitled\">\n\nHere we can see the headers returned by the server when making a GET request to [evilsaint.com](evilsaint.com)\n\n## 4, Checking what versions of SSL/TLS the server will support\n\n```powershell\n“ssl2”, “ssl3”, “tls”, “tls11”, “tls12” | % {\n\n    $TcpClient = New-Object Net.Sockets.TcpClient\n    $TcpClient.Connect(\"evilsaint.com\", 443)\n    try {\n        $SslStream = New-Object Net.Security.SslStream $TcpClient.GetStream()\n        $SslStream.ReadTimeout = 15000\n        $SslStream.WriteTimeout = 15000\n        $SslStream.AuthenticateAsClient(\"evilsaint.com\",$null,$_,$false)\n        $KeyExhange = $SslStream.KeyExchangeAlgorithm\n        $HashAlgorithm = $SslStream.HashAlgorithm\n        $status = $true\n\n    } catch {\n        $status = $false\n    }\n\n    $TcpClient.Dispose()\n    $SslStream.Dispose()\n\n    Write-Host \"$_ = $status\"\n    #Write-Host $KeyExhange\n    #Write-Host $HashAlgorithm\n}\n```\n<img src=\"/static/ee1e0133-5cee-4894-9031-35565478119d.png\" class=\"img-fluid\" alt=\"untitled\">\n\nHere we can see that [evilsaint.com](http://evilsaint.com) does not support SSL version 2 or 3\n\n## 5, Alive Hosts And Open Port Detection\n\nWhile ideally, we would always have tools such as Nmap, Masscan and Hping3 to hand, sometimes, we just had to live-of-the-land. \n\nTo see if a host is alive, we can use `Test-NetConnection` to send an ICMP ping request. \n\n```powershell\nTest-NetConnection evilsaint.com\n```\n\nIf we specify a port, then PowerShell will attempt a TCP connect test to that port.\n\n```powershell\nTest-NetConnection [evilsaint.com](http://evilsaint.com/) -Port 443\n```\n\nWith a little scripting, we can use the Net Sockets TCP Client and loop through many ports like so\n\n```powershell\n1..1024 | % {echo ((new-object Net.Sockets.TcpClient).Connect(\"[evilsaint.com](http://evilsaint.com/)\",$*)) \"Port $* is open!\"} 2>$null\n```\n\nThis can be quite a slow process.\n\n<img src=\"/static/ca18b1d9-c600-48ae-9082-fd3ecbb01b35.png\" class=\"img-fluid\" alt=\"untitled\">\n\n\nHere we can see Port 22 has been left open :-)"}}},"staticQueryHashes":["310218920"],"slicesMap":{}}