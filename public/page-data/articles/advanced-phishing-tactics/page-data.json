{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/advanced-phishing-tactics/","result":{"pageContext":{"post":{"fields":{"slug":"/advanced-phishing-tactics"},"excerpt":"","frontmatter":{"date":"17th August 2021 ","title":"Advanced Phishing Tactics","description":"This is the article summary at the top.","tags":"red-teaming","posttype":"article"},"body":""},"prev":{"fields":{"slug":"/web-security-headers"},"excerpt":null,"frontmatter":{"date":"2nd January 2022 ","title":"Web Security Headers","description":"Web application security headers can make a big difference in reducing the attack surface of a clients application. Knowing the differences is an essential part of a consultants repertoire.","tags":"browsers, content-security-policy, csp, hsts, security-headers, strict-transport-security, x-content-type-options, x-frame-options","posttype":"article"},"body":"HTTP Headers are typically easy to implement and can significantly increase the security of your website and help prevent security vulnerabilities like Cross-Site Scripting, Clickjacking, Information disclosure and more. In this article, we are concerned chiefly with five security headers that can be implemented to improve the security posture of your website.\n\n- X Frames Options\n    - X-Frames-Options\n- XSS Protection\n    - *X-XSS-Protection*\n- X Content-Type Options\n    - *X-Content-Type-Options*\n- Strict Transport Security Header (HSTS)\n    - *Strict-Transport-Security*\n- Content Security Policy (CSP)\n    - *Content-Security-Policy*\n\nWhile these headers are certainly not in order of importance, I have purposely left Security Headers with more discussion points until later in this article.\n\nA quick word on setting headers. While the exact location of a webservers domain configuration file can be customised, it is quite common for the Nginx and Apache Configuration files to be at the following locations named typically after the web domain name or utilising the default configuration example. If your website was `something.com`, then check for a file called `something.com.conf` or potentially `default.conf` if the default template file was used.\n\n- /etc/apache2/sites-enabled/<website name|default>.conf\n- /etc/nginx/sites-enabled/<website name|default>.conf file:\n\n## X Frames Options - X-Frames-Options\n\nThe X-Frame-Options HTTP response header can be used to indicate whether or not a browser should be allowed to render a page in a `<frame>`, `<iframe>`, `<embed>` or `<object>`. Sites can use this to avoid clickjacking attacks by ensuring that their content is not embedded into other sites.\n\nThere are three ways to configure X-Frame-Options:\n\n**DENY:** This will disable iframe features altogether.\n\n**SAMEORIGIN:** iframe can be used only by someone of the same origin.\n\n**ALLOW-FROM:** This will allow pages to be put in iframes only from specific URLs.\n\nNginx\n\n```bash\nadd_header X-Frame-Options \"SAMEORIGIN\";\n```\n\nApache\n\n```bash\nHeader always set X-Frame-Options \"SAMEORIGIN\"\n```\n\n## XSS Protection - *X-XSS-Protection*\n\nThe XSS Protection header is an older security header that enables cross-site scripting protection in Internet Explorer, Chrome and Firefox. Although this functionality is now provided by CSP, which allows us to block inline JavaScript, the header can still provide protection when used with older browsers that do not support the Content Security Policy header.\n\nYou can implement XSS protection using the three options depending on the specific need.\n\n**X-XSS-Protection: 0**: This will disable the filter entirely.\n\n**X-XSS-Protection: 1**: This will enable the filter but only sanitizes potentially malicious scripts.\n\n**X-XSS-Protection: 1; mode=block**: This will enable the filter and completely blocks the page.\n\nNginx\n\n```bash\nadd_header X-XSS-Protection \"1; mode=block\";\n```\n\nApache\n\n```bash\nHeader set X-XSS-Protection \"1; mode=block\"\n```\n\n## X Content-Type Options - X-Content-Type-Options\n\nThis header tells the browser that the Multipurpose Internet Mail Extensions (MIME) types advertised in the Content-Type header should be followed. This header was first introduced by Microsoft to prevent MIME sniffing.\n\nMIME sniffing is where a browser looks at the contents of a given resource and attempts to detect the MIME type. An attack vector can open up if an attacker can control the content of a resource or upload a new resource to a website, and this Security Header is not advertised in the resource response. The attacker might make non-executable content appear to be executable content and trick the browser into executing it in the victim's browser.\n\nNginx\n\n```bash\nadd_header X-Content-Type-Options \"nosniff\"\n```\n\nApache\n\n```bash\nHeader set X-Content-Type-Options \"nosniff\"\n```\n\n## Strict Transport Security Header (HSTS) - *Strict-Transport-Security*\n\nThe first header for discussion is the Strict Transport Security Header (HSTS). The HSTS forces web browsers or clients to communicate with servers but only through HTTPS connections. HSTS ensures that connections only use HTTPS and prevent man in the middle, downgrade, and cookie hijacking attacks. HSTS is a trust on first use (sometimes abbreviated as TOFU), meaning it must send at least one insecure connection over HTTP to the host to transfer the security header.\n\nThe HSTS preload list is an effort to provide browsers with a list of sites that support HSTS to avoid this initial, insecure connection. However, suppose a site is not on the list but uses the 'strict-transport-security' header; after the initial exchange, the browser will only request access to the website over Transport Layer Security (TLS).\n\nNginx\n\n```bash\nadd_header Strict-Transport-Security 'max-age=31536000; includeSubDomains; preload';\n```\n\nApache\n\n```bash\nHeader set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"\n```\n\n## Content Security Policy (CSP) - *Content-Security-Policy*\n\nContent Security Policy, sometimes abbreviated as CSP, is a security header that helps mitigate the risk of certain types of data injection attacks such as cross-site scripting. CSP allows website administrators to eliminate or mitigate cross-site scripting by defining a policy that stipulates what locations browsers should trust and allows script execution. The Content Security Policy header is sometimes referred to as a poor man's Web Application Firewall (WAF).\n\nThis header is set in HTTP response when an HTML document is requested by a user. Content Security Policy enables the website to list precisely which domains the HTML document can load scripts from. Browsers then deny requests for scripts from any other servers.\n\nThe architecture of this policy allows sites to safelist only servers containing resources they need, such as CDNs and plugins. As a result, if an attacker successfully gets a page to request a script through a cross-site scripting attack, the browser will refuse to load the script because the origin isn't on the safelist.\n\nIn addition to disallowing non-whitelisted sites, a site that implements the Content Security Policy header no longer supports inline JavaScript. This means that sites must remove code within script tags in an HTML file, JavaScript URLs, and inline event handlers and handle those tasks using script files instead.\n\nAs an ultimate form of protection, sites that want to never allow scripts to be executed can opt to globally disallow script execution. In addition to restricting the domains from which content can be loaded, the server can specify which protocols were allowed. So, for example, a server can specify that all content must be loaded using HTTPS.\n\nHowever, it should be noted that as part of a defence in depth approach, all cookies should be marked with a secure flag to ensure that they can't be transmitted over HTTP.\n\nNginx\n\n```bash\nadd_header Content-Security-Policy \"default-src 'self'; font-src *;img-src * data:; script-src *; style-src *\";\n```\n\nApache\n\n```bash\nHeader always set Content-Security-Policy \"default-src 'self'; font-src *;img-src * data:; script-src *; style-src *;\"\n```"},"next":{"fields":{"slug":"/securely-accessing-remote-docker-host"},"excerpt":"Docker is running out box without the socket set evilsaint@marvel.lab:~# docker ps\nCannot connect to the Docker daemon at unix:///var/run…","frontmatter":{"date":"16th August 2021 ","title":"Securely Accessing Remote Docker Host","description":"The Docker TCP socket by default doesn't support any authentication. and, if the Docker socket is exposed on an external interface, anyone can connect to it and issue docker commands. This can even lead to host takeover if the Docker daemon is running as root.","tags":"docker","posttype":"article"},"body":"Docker is running out box without the socket set\n```\nevilsaint@marvel.lab:~# docker ps\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n\nevilsaint@marvel.lab:~# docker images\nCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\n```\n\n\nNmap Scan showing exposed Docker API port. \n```\nnmap -sSV -p- 192.190.96.3\nStarting Nmap 7.91 ( https://nmap.org ) at 2021-08-17 00:34 IST\nNmap scan report for docker-host (192.190.96.3)\nHost is up (0.000015s latency).\nNot shown: 65532 closed ports\nPORT     STATE SERVICE    VERSION\n22/tcp   open  ssh        OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)\n2375/tcp open  docker     Docker 19.03.1 (API 1.40)\n2376/tcp open  tcpwrapped\nMAC Address: 02:42:C0:BE:60:03 (Unknown)\nService Info: OSs: Linux, linux; CPE: cpe:/o:linux:linux_kernel\n\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 9.11 seconds\n````\n\n\nDefine the DOCKER_HOST environment variable to point to this remote TCP socket.\n```\nexport DOCKER_HOST=192.190.96.3:2375\n```\n\nNow we can mount the image to the host volume and do a host breakout if permissions are in place\n```\nevilsaint@marvel.lab:~# docker run -it -v /:/host ubuntu:18.04 bash\nroot@6a01ea2ace07:/# chroot /host\n#\n```\n\n## How can we secure this \n\nI will SSH into the remote host to perform the fix \n\nLet us kill the docker\n```\nps -ef | grep docker\n```\n\n```\nkill <pid>\n```\n\nRestart the docker service\n```\nservice docker start\n```\n\nNow we export the docker host to be accessible over SSH\n```\nroot@localhost:~# export DOCKER_HOST=ssh://root@192.190.96.3\n```"}}},"staticQueryHashes":["310218920"],"slicesMap":{}}