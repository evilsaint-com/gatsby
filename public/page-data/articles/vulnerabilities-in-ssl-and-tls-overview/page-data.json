{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/vulnerabilities-in-ssl-and-tls-overview/","result":{"pageContext":{"post":{"fields":{"slug":"/vulnerabilities-in-ssl-and-tls-overview"},"excerpt":"Since January 6th, we have been looking at individual SSL/TLS vulnerabilities. This article will provide an overview of the series and…","frontmatter":{"date":"24th January 2022 ","title":"Vulnerabilities in SSL & TLS :- Overview","description":"Since January 6th, we have been looking at individual SSL/TLS vulnerabilities. This article will provide an overview of the series and provide background information on SSL/TLS for those who are unfamiliar with the subject. If you scroll to the bottom, you will find a handy reference sheet for when you are on the phone with customers.","tags":"ssl, tls","posttype":"article"},"body":"Since January 6th, we have been looking at individual SSL/TLS vulnerabilities. This article will provide an overview of the series and provide background information on SSL/TLS for those who are unfamiliar with the subject. \n\nA timeline of SSL and TLS development:\n\n- SSL 2.0. Released in 1995, this version of SSL is now prohibited by the Internet Engineering Task Force (see RFC-6176).\n- SSL 3.0. Released in 1996, SSL 3.0 is deprecated, but a few browsers still support it (RFC-7568).\n- TLS 1.0. Released in 1999 and deprecated in 2020.\n- TLS 1.1. Released in 2006 and deprecated in 2020.\n- TLS 1.2. Released in 2008 and still has no security issues.\n- TLS 1.3. Released in 2018 and continues to be the main protocol used today without any known vulnerabilities.\n\nIn this article series we will cover:\n\n1. [Heartbleed](https://evilsaint.com/article/vulnerabilities-ssl-tls-heartbleed/) \n2. [SWEET32](https://evilsaint.com/article/vulnerabilities-ssl-tls-sweet32/) \n3. [DROWN](https://evilsaint.com/article/vulnerabilities-ssl-tls-drown/) \n4. [FREAK](https://evilsaint.com/article/vulnerabilities-ssl-tls-freak/) \n5. [logjam](https://evilsaint.com/article/vulnerabilities-ssl-tls-logjam/) \n6. [BEAST](https://evilsaint.com/article/vulnerabilities-ssl-tls-beast/) \n7. [BREACH](https://evilsaint.com/article/vulnerabilities-ssl-tls-breach/) \n8. [RC4 Biases](https://evilsaint.com/article/vulnerabilities-ssl-tls-rc4-byte-biases/) \n9. [CCS injection vulnerability](https://evilsaint.com/article/vulnerabilities-ssl-tls-ccs-injection-vulnerability/) \n10. [POODLE](https://evilsaint.com/article/vulnerabilities-ssl-tls-poodle/) \n11. [POODLE over TLS](https://evilsaint.com/article/vulnerabilities-ssl-tls-poodle-over-tls/) \n12. [Lucky13](https://evilsaint.com/article/vulnerabilities-ssl-tls-lucky13/) \n13. [TLS Renegotiation](https://evilsaint.com/article/vulnerabilities-ssl-tls-tls-renegotiation/) \n\n\n## Quick Guide\n\nRight now, if you have the client on the phone, however...\n\nAttack | CVE | Affects | Mitigation \n:-----:|:-----:|:-----|:-----\nLogjam | CVE-2015-4000 | The TLS protocol 1.2 and earlier when a DHE_EXPORT cipher suite is enabled. | Enforce DH group sizes of 1,024 bits and above\nPOODLE | CVE-2014-3566 | SSL version 3.0 | Disable support for SSL 3.0\nBEAST | CVE-2011-3389  | TLS 1.0 or any version of SSL | Enforce TLS 1.1 and higher\nCRIME | 2012-4929  | TLS compression| Disable TLS compression\nBREACH and TIME | CVE-2013-3587 | HTTP compression | Disable HTTP compression\nLucky 13 | CVE-2013-0169 | TLS protocol 1.1 and 1.2 and the DTLS protocol 1.0 and 1.2 in several vendors products | Disable CBC ciphers if your server implementation is flawed\nRC4 byte biases | CVE-2013-2566  | Connections supporting RC4 | Disable support for RC4 cipher suites\nFREAK | CVE-2015-0204  | Any system willing to negotiate RSA Export Keys.  | Disable support for weak export-grade ciphers\nSWEET32 | CVE-2016–2183 and CVE-2016–6329 | Long term client browser foothold | Do not support or negotiate 3DES cipher-suites. At a minimum, AES should be preferred over 3DES. Limit length of TLS session."},"prev":{"fields":{"slug":"/linux-security-secure-shell-ssh-introduction"},"excerpt":null,"frontmatter":{"date":"27th January 2022 ","title":"Linux Security :- Secure Shell (SSH) Introduction","description":"This article serves as an introduction to the Secure Shell (SSH) protocol for Linux users. When you need to connect to Linux servers remotely, SSH is the most commonly used method. SSH provides a text interface by spawning a remote shell. All commands entered in your local terminal are sent to the remote server and executed there.","tags":"linux, ssh","posttype":"article"},"body":"\n###What is SSH?\n\nSSH, or Secure Shell, is a \"tried and tested\" protocol that has been in use since 1995. The SSH protocol allows remote servers to be controlled and modified securely, even over insecure networks. This is accomplished through a text interface, which accepts input from your local terminal and sends it to the remote server for execution; All the while providing encryption for the communication exchanged.\n\n###SSH enumeration with Linux\n\nObtaining information from running services is used by penetration testers during the enumeration phase of an engagement to gain insight into the target(s) under review. We can ascertain the following from the SSH protocol:\n  \n* SSH package version - You might be able to find the operating system and version.  \n* SSH key fingerprint - Has the key been re-used somewhere (Another machine? Same machine, just another port/service?).  \n* SSH banner - Any text (if at all) before the password prompt (often get legal warnings about connecting to it).\n\nLet us look into acquiring this information with our Linux-based machine.\n\n#### Server version\n\nSSH operates on a client-server architecture. In this architecture, the host being accessed acts as an SSH server, while the host connecting the server acts as an SSH client. Both these utilise the SSH protocol with the help of software; The most common of which is the OpenSSH package for Linux-based systems. \n\nTo find out the SSH server software and its version in use, we can use netcat.\n\n```\nnc 10.0.0.1 22\n\nSSH-2.0-OpenSSH_8.4p1 Debian-6\n```\n\n#### Fingerprinting\n\nSSH keys provide access without the need for passwords. They consist of public and private key pairs, which act as means to encrypt and decipher data exchanged. \n\nPublic keys can also be used to verify the identity of the offering party. A hash obtained from the public key, is also known as fingerprint. SSH servers display their fingerprints to users when they first connect to the server, or the public key of the server has changed since the last time a connection was initiated. \n\nTo obtain the fingerprint of a server, you can use the SSH client on Linux.\n\n```\nroot@kali:~# ssh root@10.11.1.71  \n\n\nThe authenticity of host '10.11.1.71 (10.11.1.71)' can't be established.  \nECDSA key fingerprint is SHA256:AibCWx1KvdJmNHd3KVsYksWtveJPdLZAsHMIChsTeHE.  \nAre you sure you want to continue connecting (yes/no)?  \n```\n\n#### SSH Banner\n\nBefore allowing authentication, the SSH server can display a pre-configured message to its users. If an SSH banner is configured, you can see it while fingerprinting the server as described above.\n\n#### Nmap\n\nNmap is a network mapping tool that is an essential part of every penetration tester's arsenal. The installation comes with Nmap Scripting Engine (NSE), which allows users to write and share network enumeration scripts. These scripts are most typically located at /usr/share/nmap on Linux machines.\n\nTo view which SSH scripts are available with your version of nmap, use `ls` . \n\n```\nbash  \nroot@root:~/# ls -ls /usr/share/nmap/scripts/*ssh*\n8 -rw-r--r-- 1 root root 5659 Sep 2 2016 /usr/share/nmap/scripts/ssh2-enum-algos.nse  \n16 -rw-r--r-- 1 root root 15363 Sep 2 2016 /usr/share/nmap/scripts/ssh-hostkey.nse  \n4 -rw-r--r-- 1 root root 1446 Sep 2 2016 /usr/share/nmap/scripts/sshv1.nse`  \n```\n\nThe nmap host key script allows fingerprinting and banner grabbing across the network.\n\n```\nnmap 192.168.1.0/24 -p 22 -sV --script=ssh-hostkey  \n\n[...]\n| ssh-hostkey: Possible duplicate hosts\n| Key 1024 60:ac:4d:51:b1:cd:85:09:12:16:92:76:1d:5d:27:6e (DSA) used by:\n|   192.168.1.1\n|   192.168.1.2\n| Key 2048 2c:22:75:60:4b:c3:3b:18:a2:97:2c:96:7e:28:dc:dd (RSA) used by:\n|   192.168.1.1\n|_  192.168.1.2\n```\n\n#### Hydra\n\nSSH servers can be configured to support password authentication. This means that upon connecting, a username and password are required for the user to log in. Unlike key-based authentication, password authentication exposes the server brute force password attacks.\n\nHydra is a tool for performing brute force attacks on SSH. These attacks can be set to use a word list, a password list, or a host list.\n\nSeveral hosts with a username and a password list:\n\n```\nhydra -L /usr/share/ncrack/default.usr  -P /usr/share/wordlists/rockyou.txt -M hosts.txt ssh\n```\n\nOne host with a password list against a single user (\"root\"):\n\n```\nhydra -l root -P /usr/share/wordlists/rockyou.txt 10.1.1.1 ssh\n```\n\nHydra flags:\n\n```bash  \n-M = (FILE) server list for parallel attacks, one entry per line  \n-e nsr = \"n\" null password, \"s\" try login as pass, \"r\" try pass as login  \n-s = (PORT) if the service is on a different default port, define it here  \n-l or -L = single username login or username from FILE  \n-p or -P = single password login or password from FILE  \n```\n\n#### Word lists  \n\nThe success rate of a brute force attack is only as high as the quality of the word list used. Word lists should be chosen with the basis of information gathered within the enumeration phase. For example, attacking the \"root\" username on a Windows-based SSH server is less likely to grant access than attacking it on a Linux-based SSH server.\n\nMulti-purpose username lists:\n\n```\n/usr/share/ncrack/default.usr  \n\n/usr/share/metasploit-framework/data/wordlists/default_users_for_services_unhash.txt  \n```\n\nThe most 14344392 popular passwords from a breached password database collection:\n\n```\n/usr/share/wordlists/rockyou.txt  \n```\n\n### About SSH keys  \n  \nSSH keys are a more secure way of logging into a server with SSH than a password alone. As we have uncovered earlier, a brute force attack can eventually crack a password; However, it is nearly impossible to decipher SSH keys with brute force alone. \n\nWhen generating a key pair, you will end up with two long strings of characters: a public and a private key. You can put the public key on any server and then unlock it by connecting with a client that has the private key. When the two match, the system unlocks without requiring a password. You can boost security even further by encrypting the private key with a password.\n\n#### How to set up SSH keys \n\n<https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2>  \n  \nIn case of key-based authentication, the SSH connection requires two key pairs:\n\n* Your client software compares the server's (host) public key to data encrypted with the host private key. This necessitates having a copy of the server's public key, which you are given at the first connection and which your client stores if you approve of it.\n* The server verifies your authentication data, which is encrypted with your user private key, using a copy of your user public key that it has because you placed it there (or had someone put there for you).\n  \n#### Step One - Create the RSA key pair  \n  \nThe first step is to create the key pair on the client machine (which is likely just your computer):\n  \n```\nssh-keygen -t rsa  \n```\n\n#### Step Two - Store the keys and passphrase  \n  \nOnce you have entered the Gen Key command, you will get a few more questions:  \n  \n```\nEnter file in which to save the key (/home/demo/.ssh/id_rsa):  \n```\n  \nYou can press enter here, saving the file to the user's home (in this case, my example user is called demo). \n\nNext, you will be prompted for a passphrase.\n  \n```\nEnter passphrase (empty for no passphrase):  \n```\n\nIt is entirely up to you whether or not to use a passphrase. Entering a passphrase has advantages: the security of a key, no matter how encrypted, is still dependent on the fact that it is not visible to others. If an unauthorised user obtains a pass-protected private key, they will be unable to log in to the accounts associated with it until they figure out the passphrase, buying the hacked user some time. The only disadvantage of having a passphrase is having to type it in each time you use the key pair.\n  \nThe entire key generation process looks like this:  \n\n```bash  \nssh-keygen -t rsa  \nGenerating public/private rsa key pair.  \nEnter file in which to save the key (/home/demo/.ssh/id_rsa):  \nEnter passphrase (empty for no passphrase):  \nEnter same passphrase again:  \nYour identification has been saved in /home/demo/.ssh/id_rsa.  \nYour public key has been saved in /home/demo/.ssh/id_rsa.pub.  \nThe key fingerprint is:  \n4a:dd:0a:c6:35:4e:3f:ed:27:38:8c:74:44:4d:93:67 demo@a  \nThe key's randomart image is:  \n+--[ RSA 2048]----+  \n| .oo. |  \n| . o.E |  \n| + . o |  \n| . = = . |  \n| = S = . |  \n| o + = + |  \n| . o + o . |  \n| . o |  \n| |  \n+-----------------+  \n  \nThe public key is now located in /home/demo/.ssh/id_rsa.pub The private key (identification) is now located in /home/demo/.ssh/id_rsa  \n```\n\n#### Step Three - Copy the public key  \n\nOnce the key pair has been generated, the public key should be placed on the server that we intend to use.\n  \nUsing the ssh-copy-id command, you can copy the public key into the new machine's authorized_keys file. Replace the example username and IP address below with your own.\n  \n```\nssh-copy-id user@10.1.1.1\n```\n\nAlternatively, you can paste in the keys using SSH:  \n  \n```\ncat ~/.ssh/id_rsa.pub | ssh user@10.1.1.1 \"mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys\"  \n```\n\nNo matter which command you use, you should see something like this:  \n\n```  \nThe authenticity of host '10.1.1.1 (10.1.1.1)' can't be established.  \nRSA key fingerprint is b1:2d:33:67:ce:35:4d:5f:f3:a8:cd:c0:c4:48:86:12.  \nAre you sure you want to continue connecting (yes/no)? yes  \nWarning: Permanently added '10.1.1.1' (RSA) to the list of known hosts.  \nuser@12.34.56.78's password:  \n```\n\nYou can now log in to user@10.1.1.1 without being prompted for a password. However, if you set a password, you will be prompted to enter it at that time (and every time you log in in the future). \n\n#### Optional Step Four -Disable the password for root login  \n  \nOnce you have copied your public key to the server and confirmed that you can log in using just the SSH keys, you can restrict root login to SSH keys only.\n\nTo do this, open the SSH configuration file:\n\n```\nsudo nano /etc/ssh/sshd_config  \n```\n\nFind the line that includes PermitRootLogin and change it to ensure that users can only connect using their SSH key:\n\n```\nPermitRootLogin without-password  \n```\n\nPut the changes into action:\n\n```\nreload ssh\n```"},"next":{"fields":{"slug":"/vulnerabilities-in-ssl-and-tls-tls-renegotiation"},"excerpt":"Main Points SSL/TLS client-initiated renegotiation is a feature that allows the client to renegotiate new encryption parameters for an SSL…","frontmatter":{"date":"23rd January 2022 ","title":"Vulnerabilities in SSL & TLS :- TLS  Renegotiation","description":"In this article, we will look at the TLS Renegotiation Vulnerability in the SSL and TLS protocols. This is a plaintext injection attack into previously sent packets. TLS and SSL 3.0 do not correctly associate renegotiation handshakes with existing connections. This allows a person-in-the-middle positioned attacker to insert data into a HTTPS session.","tags":"insecure-tls-renegotiation, ssl, tls","posttype":"article"},"body":"## Main Points\n\n- SSL/TLS client-initiated renegotiation is a feature that allows the client to renegotiate new encryption parameters for an SSL/TLS connection within a single TCP connection.\n- During the SSL/TLS handshake, the server incurs a higher computational cost. An attacker can exploit the higher computational cost of the server by opening an SSL/TLS connection to the server and repeatedly initiating renegotiation. This would cause the server to waste resources that would otherwise be used for the server's normal function. In addition, there is the possibility of a DOS.\n- To exploit this vulnerability, the server must not support secure renegotiation and must allow client-side renegotiation.\n- A TLS session can be renegotiated over an existing secure channel to rekey or perform further authentication. A flaw was discovered in the mechanism, by which an attacker with network access could intercept and hold handshake records from a legitimate client, establish a TLS session itself with a server, send application data, initiate renegotiation, and release the legitimate handshake records. As renegotiation is performed over an existing channel, the server believes the session is one and the same.\n\n## Quick Reference\n\n### TLDR\n\nThis is a plaintext injection attack into previously sent packets. TLS and SSL 3.0 do not correctly associate renegotiation handshakes with existing connections. This allows a person-in-the-middle positioned attacker to insert data into a HTTPS session.\n \n### Name\n\nTLS Renegotiation Vulnerability\n\n### CVE Number\n\nThe TLS protocol, and SSL protocol 3.0 (and possibly earlier)\n\n### Microsoft Vulnerability\n\nMS10-049\n\n### Type of Vulnerability\n\nWithin the protocol. \n\n### Affected\n\nThe TLS protocol, SSL protocol 3.0 and possibly earlier versions of SSL. \n\n### Remediation\n\nAvoid renegotiation, or cryptographically bind original and renegotiation TLS handshakes with the secure renegotiation extension."}}},"staticQueryHashes":["310218920"],"slicesMap":{}}